# Bash Scripting Basics

A guide explaining the fundamental concepts of Bash scripting.

### Shebang

Before anything else, you should start your script with a **Shebang**. This line tells the system which interpreter to use to execute the file.

For example, to use Bash:

```bash
#!/bin/bash
```

---
### Defining Variables

**Local Variable** A variable that is only available within the script where it is defined.

```bash
VAR="Value"
```

**Global Variable** To make a variable available to any sub-shells or child processes, you must `export` it.

```bash
export VAR="Value"
```

---
### Running a Bash Script

There are three common ways to execute a Bash script:

1. **Make the file executable** This method requires the script to have a shebang.
    
    ```bash
    # 1. Add execute permissions to the file
    chmod +x your_script_name.sh
    
    # 2. Run the script
    ./your_script_name.sh
    ```
    
2. **Using the `bash` command** This runs the script in a new sub-shell. Environment variables changed by the script will **not** affect your current shell.
    
    ```bash
    bash your_script_name.sh
    ```
    
3. **Using the `source` command** This runs the script in the _current_ shell. Any environment variables changed by the script **will** affect your current shell.
    
    ```bash
    source your_script_name.sh
    ```
    
---
### User Input

You can get input from the user with the `read` command.

**Reading Input** The `-p` flag is used to display a prompt message without a newline. The `-s` flag makes the input silent (for passwords), and `-r` prevents backslash interpretation.

```bash
read -rp "Please enter your name: " user_name
```

**Printing Output** Use the `echo` command to print the variable's value. You must prefix the variable name with a `$`.

```bash
# Print just the variable
echo $user_name

# or print it within a string
echo "Hello, $user_name!"
```

---
### Command-Line Arguments

You can pass arguments to your script when you run it from the command line.

For example:

```bash
./your_script.sh argument1 "argument 2"
```

Inside the script, you can access these arguments using special variables:

- `$#`: Stores the total number of arguments.
    
    ```bash
    # This command prints the number of arguments
    echo "You provided $# arguments."
    ```
    
- `$0`: The name of the script itself.
    
- `$1`, `$2`, etc.: The arguments themselves. `$1` is the first argument, `$2` is the second, and so on.
    
    ```bash
    # This command prints the first argument
    echo "The first argument is: $1"
    ```
    
- `$@`: Expands to all the arguments as separate words. This is useful for iterating over all the arguments.
    
    ```bash
    # This command loops through all the arguments and prints them one by one
    for arg in "$@"
    do
        echo "Argument: $arg"
    done
    ```
    
---
### Quoting

The difference between single and double quotes is very important in Bash.

1. **Single Quotes (`'`)** Everything inside single quotes is treated as a literal string. No variable expansion or command substitution will occur.
    
    ```bash
    VAR="World"
    echo 'Hello, $VAR'
    # Output: Hello, $VAR
    ```
    
2. **Double Quotes (`"`)** Double quotes allow for variable expansion and command substitution. Special characters are interpreted.
    
    ```bash
    VAR="World"
    echo "Hello, $VAR"
    # Output: Hello, World
    ```
    
    You can also run commands inside double quotes using `$(...)`:
    
    ```bash
    # This will print "test " followed by the output of the ls command
    echo "test $(ls)"
    ```
    
    To print a special character literally inside double quotes, you can escape it with a backslash (`\`):
    
    ```bash
    # This will print "hello $(ls)" literally
    echo "hello \$(ls)"
    ```
    
---
### Word Splitting

When a variable contains spaces and is used without quotes, Bash performs "word splitting" and treats each word as a separate argument.

```bash
VARA=Hello
VARB="Hello There"

# This will create one directory named "Hello"
mkdir $VARA

# This will create TWO directories: one named "Hello" and one named "There"
mkdir $VARB

# To treat the variable's value as a single argument, enclose it in double quotes:
mkdir "$VARB" # This creates one directory named "Hello There"
```

---
### Arithmetic Operations

To perform math in Bash, use the `$((...))` arithmetic expansion syntax.

```bash
x=10
y=5

# Addition
echo $((x + y)) # Output: 15

# Subtraction
echo $((x - y)) # Output: 5

# Multiplication
echo $((x * y)) # Output: 50

# Division
echo $((x / y)) # Output: 2

# Power / Exponentiation
echo $((y ** 2)) # Output: 25

# Incrementing a variable
((x++))
echo $x # Output: 11
```

The following operators are available inside `((...))`: `+`, `-`, `*`, `/`, `%` (modulo), `**` (exponentiation), `++`, `--`, `+=`, `-=`, `==` (equality), `!=` (not equal), `&&` (logical AND), `||` (logical OR).

---
### Conditional Statements

There are two main ways to handle conditions in Bash: `if` statements and `case` statements.

#### 1. `if` Statements

The `if` statement allows you to execute code based on a condition.

**Syntax:**

- **Multi-line (Recommended):**
    
    ```bash
    if [[ condition ]]
    then
        # statement to execute if condition is true
        # You can use 'exit' to terminate the script.
        # exit 0 --> indicates success
    elif [[ another_condition ]]
    then
        # statement to execute if another_condition is true
        # exit [1-255] --> indicates an error
    else
        # statement to execute if no conditions are true
    fi
    ```
    
- **Single-line:**
    
    ```bash
    if [[ condition ]]; then echo "True"; else echo "False"; fi
    ```
    
---
**Understanding Test Expressions: `[ ]` vs `[[ ]]`**

Bash provides two primary ways to evaluate test expressions: `[ ]` (single brackets) and `[[ ]]` (double brackets). Understanding the differences is crucial for writing effective conditional statements.

- **Single Brackets `[ ]`**
    
    - **Usage:** Traditional `test` command.
        
    - **Compatibility:** More portable across different shells (Bourne shell compatible).
        
    - **Limitations:** Less powerful; requires careful quoting of variables to prevent word splitting and globbing issues.
        
- **Double Brackets `[[ ]]`**
    
    - **Usage:** An enhanced test command specific to Bash.
        
    - **Features:** Prevents word splitting and globbing, supports additional operators like pattern matching (`=~`), and allows logical operators like `&&` and `||` inside.
        
---
**Common Comparison Operators**

Bash offers a variety of operators to compare integers, strings, and file attributes.

- **Numeric Comparison Operators** (for integers)
    

|Operator|Description|
|---|---|
|`-eq`|Equal to|
|`-ne`|Not equal to|
|`-lt`|Less than|
|`-le`|Less than or equal to|
|`-gt`|Greater than|
|`-ge`|Greater than or equal to|

**Example: Numeric Comparisons**

```bash
#!/bin/bash

a=5
b=10

# Simple comparison using single brackets
if [ "$a" -lt "$b" ]; then
    echo "$a is less than $b."
fi

# Compound comparison using double brackets
if [[ "$a" -gt 3 && "$b" -le 15 ]]; then
    echo "$a is greater than 3 and $b is less than or equal to 15."
fi
```

- **String Comparison Operators**
    

|Operator|Description|Works In|
|---|---|---|
|`=`|Equal to|`[ ]` and `[[ ]]`|
|`==`|Equal to (preferred in `[[ ]]`)|`[ ]` and `[[ ]]`|
|`!=`|Not equal to|`[ ]` and `[[ ]]`|
|`<`|Less than (ASCII sort order)|`[[ ]]` only|
|`>`|Greater than (ASCII sort order)|`[[ ]]` only|

**Example: String Comparisons**

```bash
#!/bin/bash

str1="apple"
str2="banana"

if [ "$str1" = "banana" ]; then
    echo "Strings are equal."
else
    echo "Strings are not equal."
fi

if [[ "$str1" < "$str2" ]]; then
    echo "$str1 comes before $str2 alphabetically."
fi
```

- **File & Directory Operators**
    

|Operator|Description|
|---|---|
|`-e`|True if the file or directory exists.|
|`-f`|True if it exists and is a regular file.|
|`-d`|True if it exists and is a directory.|
|`-s`|True if the file exists and is not empty.|
|`-r`|True if the file is readable.|
|`-w`|True if the file is writable.|
|`-x`|True if the file is executable.|

**Example: File Attribute Checks**

```bash
#!/bin/bash

FILE="/home/ali/script.sh"

if [ -f "$FILE" ]; then
    echo "$FILE is a regular file."
fi

if [[ -x "$FILE" ]]; then
    echo "$FILE is executable."
fi
```

**Example: User Login**

```bash
#!/bin/bash

read -rp "please enter your username: " username
read -s -p "please enter your password: " password
echo

if [[ "$username" == "admin" && "$password" == "admin" ]]; then
    echo "successful login"
    exit 0
else
    echo "username or password is incorrect"
    exit 1
fi
```

**Example: Even or Odd Number**

```bash
#!/bin/bash

# Ask the user for a number
read -p "Enter a number: " number

# Check if the number is even or odd
if (( number % 2 == 0 )); then
    echo "The number is even."
else
    echo "The number is odd."
fi
```

---

**Checking the Exit Status (`$?`)**

Every command in Linux returns an **exit status** (also called a return code). This is a number between 0 and 255.

- `0` means the command was successful.
    
- Any number from `1` to `255` means the command failed.
    

The special variable `$?` always holds the exit status of the _last executed command_. You can use this to check if a command or a condition was successful.

**Example:**

```bash
if [[ -f file.txt ]]; then
    echo "The file exists on your system."
    mkdir -p hello_there # This will have an exit status of 0 if it runs well
else
    echo "File not found."
    exit 2 # Explicitly exit with an error code
fi

# Now, check the exit status of the last command (either mkdir or the script itself if it exited)
if [[ $? -eq 0 ]]; then
    echo "The program finished successfully."
else
    echo "The program finished with an error."
fi
```

> **Note:** The `[` command is an actual program (or shell builtin). You can learn more about its options by running `man [` in your terminal.

---
#### 2. `case` Statements

The `case` statement is a cleaner way to write multiple `if`/`elif`/`else` conditions when you are checking a single variable against a series of different values (patterns).

**Syntax:**

```bash
case $VARIABLE in
    pattern1)
        # commands to execute if VARIABLE matches pattern1
        ;;
    pattern2|pattern3)
        # commands to execute if VARIABLE matches pattern2 OR pattern3
        ;;
    *)
        # default commands to execute if no other pattern matches
        ;;
esac
```

**Key Points:**

- The statement starts with `case` and ends with `esac` (case spelled backward).
    
- Each block of conditions ends with `;;`.
    
- You can use the pipe `|` to represent an "OR" condition for multiple patterns.
    
- The `*)` is a wildcard pattern that acts as a default case, similar to `else`.
    

**Example 1: Service Control**

```bash
#!/bin/bash

read -p "Enter 'start', 'stop', or 'status': " command

case $command in
    start)
        echo "Starting the service..."
        ;;
    stop)
        echo "Stopping the service."
        ;;
    status|check)
        echo "Checking the service status."
        ;;
    *)
        echo "Invalid command. Please use 'start', 'stop', or 'status'."
        ;;
esac
```

**Example 2: Simple Calculator**

```bash
#!/bin/bash

read -p "Enter first number: " num1
read -p "Enter second number: " num2
read -p "Enter operator (+, -, *, /): " operator

case $operator in
    +)
        echo "$num1 + $num2 = $((num1 + num2))"
        ;;
    -)
        echo "$num1 - $num2 = $((num1 - num2))"
        ;;
    \*)
        echo "$num1 * $num2 = $((num1 * num2))"
        ;;
    /)
        if [ "$num2" -ne 0 ]; then
            echo "$num1 / $num2 = $((num1 / num2))"
        else
            echo "Error: Division by zero"
        fi
        ;;
    *)
        echo "Invalid operator!"
        ;;
esac
```

---
### Loops

Loops allow you to execute a block of code multiple times. Bash supports `for`, `while`, and `until` loops.

#### 1. `for` Loops

A `for` loop is used to iterate over a list of items and perform a given set of commands.

**Syntax 1: Iterating over a list**

```bash
for VARIABLE in item1 item2 item3 ...
do
    # commands to execute for each item
done
```

**Example:**

```bash
#!/bin/bash

# Loop through a list of fruits
for fruit in apple banana cherry
do
    echo "I like $fruit"
done
```

**Syntax 2: C-style `for` loop**

```bash
for (( INITIALIZATION; CONDITION; INCREMENT ))
do
    # commands to execute
done
```

**Example:**

```bash
#!/bin/bash

# Print numbers from 1 to 5
for (( i=1; i<=5; i++ ))
do
    echo "Count: $i"
done
```

#### 2. `while` Loops

A `while` loop executes a block of code as long as a given condition is true.

**Syntax:**

```bash
while [[ condition ]]
do
    # commands to execute
done
```

**Example:**

```bash
#!/bin/bash

counter=1
while [[ $counter -le 5 ]]
do
    echo "Counter is at $counter"
    ((counter++))
done
```

#### 3. `until` Loops

An `until` loop is the opposite of a `while` loop. It executes a block of code as long as a given condition is false.

**Syntax:**

```bash
until [[ condition ]]
do
    # commands to execute
done
```

**Example:**

```bash
#!/bin/bash

counter=1
until [[ $counter -gt 5 ]]
do
    echo "Counter is at $counter"
    ((counter++))
done
```

#### Loop Control (`break` and `continue`)

You can control the flow of your loops with the `break` and `continue` statements.

- `break`: Exits the current loop immediately.
    
- `continue`: Skips the current iteration of the loop and moves to the next one.
    

**Example:**

```bash
#!/bin/bash

# Print odd numbers from 1 to 10
for (( i=1; i<=10; i++ ))
do
    # If the number is even, skip to the next iteration
    if (( i % 2 == 0 )); then
        continue
    fi
    echo $i
done
```

---
### Functions

Functions allow you to group a set of commands together, give them a name, and then run them from other places in your script. This helps make your scripts more organized, reusable, and easier to read.

**Defining a Function**

There are two common ways to define a function.

**Syntax 1:**

```bash
function function_name {
    # commands
}
```

**Syntax 2 (more common):**

```bash
function_name() {
    # commands
}
```

> Note: You must define a function _before_ you call it in your script.

**Calling a Function**

To run the code inside a function, you simply call it by its name.

```bash
function_name
```

**Passing Arguments to Functions**

You can pass arguments to functions just like you do with scripts. Inside the function, you can access these arguments using the positional parameters `$1`, `$2`, `$3`, etc. `$0` will still refer to the script name.

**Returning Values from Functions**

Bash functions don't return values in the way many other programming languages do. They have two main ways of providing a result:

1. **Return Status:** Using the `return` command, a function can return a numeric exit status (a number from 0 to 255) to the caller. This is useful for indicating success (`return 0`) or failure (any other number). The calling script can check this status using the `$?` variable.
    
2. **Standard Output:** The most common method is to have the function `echo` or `printf` a result. The calling part of the script can then capture this output using command substitution `$(...)`.
    

**Example 1: Simple Greeting**

This function prints a simple message.

```bash
#!/bin/bash

# Define the function
greet() {
    echo "Hello, World!"
}

# Call the function
greet
```

**Example 2: Function with Arguments**

This function takes a name as an argument and prints a personalized greeting.

```bash
#!/bin/bash

greet_user() {
    # $1 refers to the first argument passed to the function
    echo "Hello, $1!"
}

# Call the function with an argument
greet_user "Alice"
greet_user "Bob"
```

**Example 3: Function Returning a Value via Output**

This function takes two numbers, adds them, and "returns" the result by printing it. The main script captures this result into a variable.

```bash
#!/bin/bash

add() {
    local num1=$1
    local num2=$2
    local sum=$((num1 + num2))
    echo $sum
}

# Call the function and capture its output into a variable
result=$(add 5 10)

echo "The sum is: $result"
```

**Example 4: Function Returning a Status**

This function checks if a file exists and returns a status code. The main script checks this status to see if the function succeeded.

```bash
#!/bin/bash

# This function checks if a file exists
check_file() {
    if [[ -f "$1" ]]; then
        return 0 # Success
    else
        return 1 # Failure
    fi
}

# Call the function
check_file "/etc/hosts"

# Check the return status of the function
if [[ $? -eq 0 ]]; then
    echo "File found successfully."
else
    echo "File not found."
fi
```